-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f" {
}
entry: Abstract value:
polyhedron of dim (3,0)
array of constraints of size 3
 0: sub + y = 0
 1: -sub + x.0 >= 0
 2: x.0 - 1 >= 0
Linear Condition:
array of constraints of size 3
 0: sub + y = 0
 1: -sub + x.0 >= 0
 2: x.0 - 1 >= 0
Tree Condition:
array of constraints of size 3
 0: 0 + 1 * sub + 0 * x.0 + 1 * y = 0
 1: 0 + -1 * sub + 1 * x.0 + 0 * y >= 0
 2: -1 + 0 * sub + 1 * x.0 + 0 * y >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (3,0)
array of constraints of size 3
 0: sub + y = 0
 1: -sub + x.0 >= 0
 2: x.0 - 1 >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f2
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f2" {
}
entry: Abstract value:
polyhedron of dim (4,0)
array of constraints of size 2
 0: -sub + sub1 + z = 0
 1: sub + y - 1 = 0
Linear Condition:
array of constraints of size 2
 0: -sub + sub1 + z = 0
 1: sub + y - 1 = 0
Tree Condition:
array of constraints of size 2
 0: 0 + -1 * sub + 1 * sub1 + 0 * y + 1 * z = 0
 1: -1 + 1 * sub + 0 * sub1 + 1 * y + 0 * z = 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (4,0)
array of constraints of size 2
 0: -sub + sub1 + z = 0
 1: sub + y - 1 = 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f3
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f3" {
	"entry" -> "return"
	"entry" -> "for.cond.preheader"
	"for.cond.preheader" -> "for.body.lr.ph"
	"for.cond.preheader" -> "return"
	"for.body.lr.ph" -> "return"
}
entry: Abstract value:
empty polyhedron of dim (1,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

return: Abstract value:
polyhedron of dim (12,0)
array of constraints of size 11
 0: -tmp - 6tmp1 - 8tmp5 + 4tmp9 = 0
 1: -tmp - 2tmp5 + tmp8 = 0
 2: -tmp1 + tmp2 = 0
 3: -2tmp5 + tmp7 = 0
 4: -2tmp5 + tmp6 = 0
 5: tmp - 6tmp1 + 4tmp4 = 0
 6: tmp - 6tmp1 + 4tmp3 = 0
 7: -4retval.0 + tmp + 6tmp1 + 8tmp5 >= 0
 8: tmp1 >= 0
 9: 49tmp - 100tmp1 >= 0
10: 2retval.0 - tmp - 2tmp1 - 4tmp5 + 2 >= 0
Linear Condition:
array of constraints of size 11
 0: -tmp - 6tmp1 - 8tmp5 + 4tmp9 = 0
 1: -tmp - 2tmp5 + tmp8 = 0
 2: -tmp1 + tmp2 = 0
 3: -2tmp5 + tmp7 = 0
 4: -2tmp5 + tmp6 = 0
 5: tmp - 6tmp1 + 4tmp4 = 0
 6: tmp - 6tmp1 + 4tmp3 = 0
 7: -4retval.0 + tmp + 6tmp1 + 8tmp5 >= 0
 8: tmp1 >= 0
 9: 49tmp - 100tmp1 >= 0
10: 2retval.0 - tmp - 2tmp1 - 4tmp5 + 2 >= 0
Tree Condition:
array of constraints of size 11
 0: 0 + 0 * retval.0 + -1 * tmp + -6 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -8 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 4 * tmp9 + 0 * y = 0
 1: 0 + 0 * retval.0 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 0 * tmp6 + 0 * tmp7 + 1 * tmp8 + 0 * tmp9 + 0 * y = 0
 2: 0 + 0 * retval.0 + 0 * tmp + -1 * tmp1 + 1 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 3: 0 + 0 * retval.0 + 0 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 0 * tmp6 + 1 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 4: 0 + 0 * retval.0 + 0 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 1 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 5: 0 + 0 * retval.0 + 1 * tmp + -6 * tmp1 + 0 * tmp2 + 0 * tmp3 + 4 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 6: 0 + 0 * retval.0 + 1 * tmp + -6 * tmp1 + 0 * tmp2 + 4 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 7: 0 + -4 * retval.0 + 1 * tmp + 6 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 8 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0
 8: 0 + 0 * retval.0 + 0 * tmp + 1 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0
 9: 0 + 0 * retval.0 + 49 * tmp + -100 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0
10: 2 + 2 * retval.0 + -1 * tmp + -2 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -4 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0

for.cond.preheader: Abstract value:
polyhedron of dim (1,0)
array of constraints of size 1
 0: -y + 100 >= 0
Linear Condition:
array of constraints of size 1
 0: -y + 100 >= 0
Tree Condition:
array of constraints of size 1
 0: 100 + -1 * y >= 0

for.body.lr.ph: Abstract value:
polyhedron of dim (11,0)
array of constraints of size 11
 0: -tmp - 2tmp5 + tmp9 + 3 = 0
 1: -tmp - 2tmp5 + tmp8 = 0
 2: -tmp + 2y = 0
 3: -tmp + 2tmp4 + 6 = 0
 4: -tmp + 2tmp3 + 6 = 0
 5: -tmp + 2tmp2 + 4 = 0
 6: -tmp + 2tmp1 + 4 = 0
 7: -2tmp5 + tmp7 = 0
 8: -2tmp5 + tmp6 = 0
 9: -tmp + 200 >= 0
10: tmp - 4 >= 0
Linear Condition:
array of constraints of size 11
 0: -tmp - 2tmp5 + tmp9 + 3 = 0
 1: -tmp - 2tmp5 + tmp8 = 0
 2: -tmp + 2y = 0
 3: -tmp + 2tmp4 + 6 = 0
 4: -tmp + 2tmp3 + 6 = 0
 5: -tmp + 2tmp2 + 4 = 0
 6: -tmp + 2tmp1 + 4 = 0
 7: -2tmp5 + tmp7 = 0
 8: -2tmp5 + tmp6 = 0
 9: -tmp + 200 >= 0
10: tmp - 4 >= 0
Tree Condition:
array of constraints of size 11
 0: 3 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 1 * tmp9 + 0 * y = 0
 1: 0 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 0 * tmp6 + 0 * tmp7 + 1 * tmp8 + 0 * tmp9 + 0 * y = 0
 2: 0 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 2 * y = 0
 3: 6 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 2 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 4: 6 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 2 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 5: 4 + -1 * tmp + 0 * tmp1 + 2 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 6: 4 + -1 * tmp + 2 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 7: 0 + 0 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 0 * tmp6 + 1 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 8: 0 + 0 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + -2 * tmp5 + 1 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y = 0
 9: 200 + -1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0
10: -4 + 1 * tmp + 0 * tmp1 + 0 * tmp2 + 0 * tmp3 + 0 * tmp4 + 0 * tmp5 + 0 * tmp6 + 0 * tmp7 + 0 * tmp8 + 0 * tmp9 + 0 * y >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (12,0)
array of constraints of size 11
 0: -tmp - 6tmp1 - 8tmp5 + 4tmp9 = 0
 1: -tmp - 2tmp5 + tmp8 = 0
 2: -tmp1 + tmp2 = 0
 3: -2tmp5 + tmp7 = 0
 4: -2tmp5 + tmp6 = 0
 5: tmp - 6tmp1 + 4tmp4 = 0
 6: tmp - 6tmp1 + 4tmp3 = 0
 7: -4retval.0 + tmp + 6tmp1 + 8tmp5 >= 0
 8: tmp1 >= 0
 9: 49tmp - 100tmp1 >= 0
10: 2retval.0 - tmp - 2tmp1 - 4tmp5 + 2 >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f4
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f4" {
	"entry" -> "if.then"
	"entry" -> "if.else"
	"if.then" -> "if.end"
	"if.else" -> "if.end"
}
entry: Abstract value:
empty polyhedron of dim (1,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

if.then: Abstract value:
polyhedron of dim (2,0)
array of constraints of size 2
 0: add + y - 7 = 0
 1: add - 8 >= 0
Linear Condition:
array of constraints of size 2
 0: add + y - 7 = 0
 1: add - 8 >= 0
Tree Condition:
array of constraints of size 2
 0: -7 + 1 * add + 1 * y = 0
 1: -8 + 1 * add + 0 * y >= 0

if.else: Abstract value:
polyhedron of dim (3,0)
array of constraints of size 3
 0: -sub1 + y - 3 = 0
 1: sub1 + sub2 + 3 = 0
 2: sub1 + 3 >= 0
Linear Condition:
array of constraints of size 3
 0: -sub1 + y - 3 = 0
 1: sub1 + sub2 + 3 = 0
 2: sub1 + 3 >= 0
Tree Condition:
array of constraints of size 3
 0: -3 + -1 * sub1 + 0 * sub2 + 1 * y = 0
 1: 3 + 1 * sub1 + 1 * sub2 + 0 * y = 0
 2: 3 + 1 * sub1 + 0 * sub2 + 0 * y >= 0

if.end: Abstract value:
polyhedron of dim (7,0)
array of constraints of size 7
 0: -3add3 + 10sub1 + 10sub2 + 21 = 0
 1: -add3 + x.0 + z.0 = 0
 2: 3add3 - 10sub1 - 5x.0 + 5y - 21 = 0
 3: -3add3 + 10sub1 + 21 >= 0
 4: -add3 + 7 >= 0
 5: add3 - 5sub1 - 5x.0 - 12 >= 0
 6: add3 + 3 >= 0
Linear Condition:
array of constraints of size 7
 0: -3add3 + 10sub1 + 10sub2 + 21 = 0
 1: -add3 + x.0 + z.0 = 0
 2: 3add3 - 10sub1 - 5x.0 + 5y - 21 = 0
 3: -3add3 + 10sub1 + 21 >= 0
 4: -add3 + 7 >= 0
 5: add3 - 5sub1 - 5x.0 - 12 >= 0
 6: add3 + 3 >= 0
Tree Condition:
array of constraints of size 7
 0: 21 + 0 * add + -3 * add3 + 10 * sub1 + 10 * sub2 + 0 * x.0 + 0 * y + 0 * z.0 = 0
 1: 0 + 0 * add + -1 * add3 + 0 * sub1 + 0 * sub2 + 1 * x.0 + 0 * y + 1 * z.0 = 0
 2: -21 + 0 * add + 3 * add3 + -10 * sub1 + 0 * sub2 + -5 * x.0 + 5 * y + 0 * z.0 = 0
 3: 21 + 0 * add + -3 * add3 + 10 * sub1 + 0 * sub2 + 0 * x.0 + 0 * y + 0 * z.0 >= 0
 4: 7 + 0 * add + -1 * add3 + 0 * sub1 + 0 * sub2 + 0 * x.0 + 0 * y + 0 * z.0 >= 0
 5: -12 + 0 * add + 1 * add3 + -5 * sub1 + 0 * sub2 + -5 * x.0 + 0 * y + 0 * z.0 >= 0
 6: 3 + 0 * add + 1 * add3 + 0 * sub1 + 0 * sub2 + 0 * x.0 + 0 * y + 0 * z.0 >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (7,0)
array of constraints of size 7
 0: -3add3 + 10sub1 + 10sub2 + 21 = 0
 1: -add3 + x.0 + z.0 = 0
 2: 3add3 - 10sub1 - 5x.0 + 5y - 21 = 0
 3: -3add3 + 10sub1 + 21 >= 0
 4: -add3 + 7 >= 0
 5: add3 - 5sub1 - 5x.0 - 12 >= 0
 6: add3 + 3 >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f5
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f5" {
	"entry" -> "return"
	"entry" -> "if.else"
	"if.else" -> "UnifiedReturnBlock"
	"return" -> "UnifiedReturnBlock"
}
entry: Abstract value:
empty polyhedron of dim (1,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

if.else: Abstract value:
polyhedron of dim (3,0)
array of constraints of size 4
 0: sub + y = 0
 1: -2.sub + 3sub - 1 >= 0
 2: -.sub + sub + 1 >= 0
 3: .sub - sub >= 0
Linear Condition:
array of constraints of size 4
 0: sub + y = 0
 1: -2.sub + 3sub - 1 >= 0
 2: -.sub + sub + 1 >= 0
 3: .sub - sub >= 0
Tree Condition:
array of constraints of size 4
 0: 0 + 0 * .sub + 1 * sub + 1 * y = 0
 1: -1 + -2 * .sub + 3 * sub + 0 * y >= 0
 2: 1 + -1 * .sub + 1 * sub + 0 * y >= 0
 3: 0 + 1 * .sub + -1 * sub + 0 * y >= 0

UnifiedReturnBlock: Abstract value:
polyhedron of dim (4,0)
array of constraints of size 5
 0: .sub - UnifiedRetVal + sub + y = 0
 1: -3.sub + 4sub >= 0
 2: -.sub + sub + 1 >= 0
 3: -.sub + UnifiedRetVal >= 0
 4: .sub - sub >= 0
Linear Condition:
array of constraints of size 5
 0: .sub - UnifiedRetVal + sub + y = 0
 1: -3.sub + 4sub >= 0
 2: -.sub + sub + 1 >= 0
 3: -.sub + UnifiedRetVal >= 0
 4: .sub - sub >= 0
Tree Condition:
array of constraints of size 5
 0: 0 + 1 * .sub + -1 * UnifiedRetVal + 1 * sub + 1 * y = 0
 1: 0 + -3 * .sub + 0 * UnifiedRetVal + 4 * sub + 0 * y >= 0
 2: 1 + -1 * .sub + 0 * UnifiedRetVal + 1 * sub + 0 * y >= 0
 3: 0 + -1 * .sub + 1 * UnifiedRetVal + 0 * sub + 0 * y >= 0
 4: 0 + 1 * .sub + 0 * UnifiedRetVal + -1 * sub + 0 * y >= 0

return: Abstract value:
polyhedron of dim (1,0)
array of constraints of size 1
 0: y >= 0
Linear Condition:
array of constraints of size 1
 0: y >= 0
Tree Condition:
array of constraints of size 1
 0: 0 + 1 * y >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (4,0)
array of constraints of size 5
 0: .sub - UnifiedRetVal + sub + y = 0
 1: -3.sub + 4sub >= 0
 2: -.sub + sub + 1 >= 0
 3: -.sub + UnifiedRetVal >= 0
 4: .sub - sub >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f6
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f6" {
	"if.end3" -> "UnifiedReturnBlock"
	"if.else" -> "UnifiedReturnBlock"
	"entry" -> "if.end3"
	"entry" -> "if.else"
}
UnifiedReturnBlock: Abstract value:
polyhedron of dim (4,0)
array of constraints of size 3
 0: -. + cmp1 = 0
 1: -. + UnifiedRetVal + 1 >= 0
 2: . - UnifiedRetVal >= 0
Linear Condition:
array of constraints of size 3
 0: -. + cmp1 = 0
 1: -. + UnifiedRetVal + 1 >= 0
 2: . - UnifiedRetVal >= 0
Tree Condition:
array of constraints of size 3
 0: 0 + -1 * . + 0 * UnifiedRetVal + 1 * cmp1 + 0 * y = 0
 1: 1 + -1 * . + 1 * UnifiedRetVal + 0 * cmp1 + 0 * y >= 0
 2: 0 + 1 * . + -1 * UnifiedRetVal + 0 * cmp1 + 0 * y >= 0

if.end3: Abstract value:
polyhedron of dim (1,0)
array of constraints of size 1
 0: -y - 1 >= 0
Linear Condition:
array of constraints of size 1
 0: -y - 1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 + -1 * y >= 0

if.else: Abstract value:
polyhedron of dim (3,0)
array of constraints of size 2
 0: -. + cmp1 = 0
 1: y >= 0
Linear Condition:
array of constraints of size 2
 0: -. + cmp1 = 0
 1: y >= 0
Tree Condition:
array of constraints of size 2
 0: 0 + -1 * . + 1 * cmp1 + 0 * y = 0
 1: 0 + 0 * . + 0 * cmp1 + 1 * y >= 0

entry: Abstract value:
empty polyhedron of dim (1,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (4,0)
array of constraints of size 3
 0: -. + cmp1 = 0
 1: -. + UnifiedRetVal + 1 >= 0
 2: . - UnifiedRetVal >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f7
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f7" {
	"entry" -> "if.then"
	"entry" -> "if.end"
	"if.then" -> "if.end"
}
if.end: Abstract value:
polyhedron of dim (2,0)
array of constraints of size 2
 0: -y.addr.0 + 30 >= 0
 1: y - y.addr.0 >= 0
Linear Condition:
array of constraints of size 2
 0: -y.addr.0 + 30 >= 0
 1: y - y.addr.0 >= 0
Tree Condition:
array of constraints of size 2
 0: 30 + 0 * y + -1 * y.addr.0 >= 0
 1: 0 + 1 * y + -1 * y.addr.0 >= 0

entry: Abstract value:
empty polyhedron of dim (1,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

if.then: Abstract value:
polyhedron of dim (1,0)
array of constraints of size 1
 0: y - 31 >= 0
Linear Condition:
array of constraints of size 1
 0: y - 31 >= 0
Tree Condition:
array of constraints of size 1
 0: -31 + 1 * y >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
polyhedron of dim (2,0)
array of constraints of size 2
 0: -y.addr.0 + 30 >= 0
 1: y - y.addr.0 >= 0

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Apron: Function: f8
Apron: Library polka, strict mode, version 3.0 with NUMINT_MPZ
digraph "f8" {
}
entry: Abstract value:
empty polyhedron of dim (3,0)
Linear Condition:
array of constraints of size 1
 0: -1 >= 0
Tree Condition:
array of constraints of size 1
 0: -1 >= 0

{'mpt':{},abstract1:{empty polyhedron of dim (0,0)
}
empty polyhedron of dim (3,0)

